-- Join Requests Table
-- This table stores requests from users who want to join projects
create table public.join_requests (
  id bigint generated by default as identity not null,
  project_id bigint not null,
  user_id uuid not null,
  message text null,
  status text not null default 'pending'::text,
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now(),
  reviewed_by uuid null,
  reviewed_at timestamp with time zone null,
  
  constraint join_requests_pkey primary key (id),
  constraint join_requests_unique_request unique (project_id, user_id),
  constraint join_requests_project_id_fkey foreign key (project_id) references projects (id) on update cascade on delete cascade,
  constraint join_requests_user_id_fkey foreign key (user_id) references public.profiles (id) on update cascade on delete cascade,
  constraint join_requests_reviewed_by_fkey foreign key (reviewed_by) references public.profiles (id) on update cascade on delete set null,
  constraint join_requests_status_check check (
    status = any (array['pending'::text, 'approved'::text, 'rejected'::text])
  )
) tablespace pg_default;

-- Indexes for better performance
create index if not exists idx_join_requests_project_id on public.join_requests using btree (project_id) tablespace pg_default;

create index if not exists idx_join_requests_user_id on public.join_requests using btree (user_id) tablespace pg_default;

create index if not exists idx_join_requests_status on public.join_requests using btree (status) tablespace pg_default;

create index if not exists idx_join_requests_created_at on public.join_requests using btree (created_at) tablespace pg_default;

-- Enable Row Level Security
alter table public.join_requests enable row level security;

-- RLS Policies

-- Users can view their own join requests
create policy "Users can view own join requests" on public.join_requests
  for select using (auth.uid() = user_id);

-- Users can create join requests (but only for themselves)
create policy "Users can create join requests" on public.join_requests
  for insert with check (auth.uid() = user_id);

-- Users can update their own pending requests (e.g., to modify message)
create policy "Users can update own pending requests" on public.join_requests
  for update using (
    auth.uid() = user_id 
    and status = 'pending'
  );

-- Project leaders can view requests for their projects
create policy "Leaders can view project join requests" on public.join_requests
  for select using (
    exists (
      select 1 from projects 
      where projects.id = join_requests.project_id 
      and projects.leader = auth.uid()
    )
  );

-- Project leaders can update requests for their projects (approve/reject)
create policy "Leaders can update project join requests" on public.join_requests
  for update using (
    exists (
      select 1 from projects 
      where projects.id = join_requests.project_id 
      and projects.leader = auth.uid()
    )
  );

-- Function to automatically update the updated_at timestamp
create or replace function public.handle_updated_at()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Trigger to automatically update updated_at on row updates
create trigger trigger_join_requests_updated_at
  before update on public.join_requests
  for each row
  execute function public.handle_updated_at();

-- Optional: Function to prevent duplicate requests and check team capacity
create or replace function public.validate_join_request()
returns trigger as $$
begin
  -- Check if user is already a member of the project
  if exists (
    select 1 from project_members 
    where project_id = new.project_id 
    and user_id = new.user_id
  ) then
    raise exception 'User is already a member of this project';
  end if;
  
  -- Check if user is the project leader
  if exists (
    select 1 from projects 
    where id = new.project_id 
    and leader = new.user_id
  ) then
    raise exception 'Project leader cannot request to join their own project';
  end if;
  
  -- Check if there's already a pending request
  if exists (
    select 1 from join_requests 
    where project_id = new.project_id 
    and user_id = new.user_id 
    and status = 'pending'
    and id != coalesce(new.id, 0)
  ) then
    raise exception 'User already has a pending request for this project';
  end if;
  
  return new;
end;
$$ language plpgsql;

-- Trigger to validate join requests before insert/update
create trigger trigger_validate_join_request
  before insert or update on public.join_requests
  for each row
  execute function public.validate_join_request();

-- Optional: Function to automatically add approved users to project_members
create or replace function public.handle_approved_join_request()
returns trigger as $$
begin
  -- If request was just approved, add user to project_members
  if new.status = 'approved' and (old.status is null or old.status != 'approved') then
    insert into project_members (project_id, user_id, role)
    values (new.project_id, new.user_id, 'member')
    on conflict (project_id, user_id) do nothing;
  end if;
  
  return new;
end;
$$ language plpgsql;

-- Trigger to automatically handle approved requests
create trigger trigger_handle_approved_join_request
  after update on public.join_requests
  for each row
  execute function public.handle_approved_join_request();